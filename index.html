<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>JJK: Cursed Technique</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', sans-serif;
        }

        #ui {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            color: #fff;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            font-size: 3rem;
            margin: 0;
            letter-spacing: 10px;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to bottom, #fff, #888);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #technique-name {
            font-size: 1.2rem;
            color: #00ffff;
            margin-top: 15px;
            font-weight: bold;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Large Centered Camera Hub - Taller for Reel Context */
        #video-container {
            position: absolute;
            bottom: 2%;
            left: 18%;
            transform: translateX(-50%) scaleX(-1);
            width: 85vw;
            max-width: 450px;
            height: 42vh;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 20;
            background-color: #000;
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.8;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
</head>

<body>

    <div id="grain"></div>

    <div id="ui">
        <h1>呪術廻戦</h1>
        <div id="technique-name">CURSED ENERGY</div>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Scene & Rendering ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 55;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const COUNT = 20000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const colors = new Float32Array(COUNT * 3);
        const sizes = new Float32Array(COUNT);

        const targetPositions = new Float32Array(COUNT * 3);
        const targetColors = new Float32Array(COUNT * 3);
        const targetSizes = new Float32Array(COUNT);

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const particles = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.3, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false }));
        scene.add(particles);

        // Technique Functions 
        function getRed(i) {
            if (i < COUNT * 0.1) {
                const r = Math.random() * 9;
                const theta = Math.random() * 6.28; const phi = Math.acos(2 * Math.random() - 1);
                return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi), r: 3, g: 0.1, b: 0.1, s: 2.5 };
            } else {
                const armCount = 3; const t = (i / COUNT);
                const angle = t * 15 + ((i % armCount) * (Math.PI * 2 / armCount));
                const radius = 2 + (t * 40);
                return { x: radius * Math.cos(angle), y: radius * Math.sin(angle), z: (Math.random() - 0.5) * (10 * t), r: 0.8, g: 0, b: 0, s: 1.0 };
            }
        }

        function getVoid(i) {
            if (i < COUNT * 0.15) {
                const angle = Math.random() * Math.PI * 2;
                return { x: 26 * Math.cos(angle), y: 26 * Math.sin(angle), z: (Math.random() - 0.5) * 1, r: 1, g: 1, b: 1, s: 2.5 };
            } else {
                const radius = 30 + Math.random() * 90;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return { x: radius * Math.sin(phi) * Math.cos(theta), y: radius * Math.sin(phi) * Math.sin(theta), z: radius * Math.cos(phi), r: 0.1, g: 0.6, b: 1.0, s: 0.7 };
            }
        }

        function getPurple(i) {
            if (Math.random() > 0.8) return { x: (Math.random() - 0.5) * 100, y: (Math.random() - 0.5) * 100, z: (Math.random() - 0.5) * 100, r: 0.5, g: 0.5, b: 0.7, s: 0.8 };
            const r = 20; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
            return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi), r: 0.6, g: 0.5, b: 1.0, s: 2.5 };
        }

        function getShrine(i) {
            const total = COUNT;
            if (i < total * 0.3) return { x: (Math.random() - 0.5) * 80, y: -15, z: (Math.random() - 0.5) * 80, r: 0.4, g: 0, b: 0, s: 0.8 };
            else if (i < total * 0.4) {
                const px = ((i % 4) < 2 ? 1 : -1) * 12; const pz = ((i % 4) % 2 == 0 ? 1 : -1) * 8;
                return { x: px + (Math.random() - 0.5) * 2, y: -15 + Math.random() * 30, z: pz + (Math.random() - 0.5) * 2, r: 0.2, g: 0.2, b: 0.2, s: 0.6 };
            } else if (i < total * 0.6) {
                const t = Math.random() * Math.PI * 2; const rad = Math.random() * 30;
                const curve = Math.pow(rad / 30, 2) * 10;
                return { x: rad * Math.cos(t), y: 15 - curve + (Math.random() * 2), z: rad * Math.sin(t) * 0.6, r: 0.6, g: 0, b: 0, s: 0.6 };
            } else return { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
        }

        function getLove(i) {
            const total = COUNT;
            if (i < total * 0.3) return { x: (Math.random() - 0.5) * 80, y: -15, z: (Math.random() - 0.5) * 80, r: 0.2, g: 0.2, b: 0.2, s: 0.6 }; //floor
            else if (i < total * 0.35) {
                const t = Math.random() * Math.PI;
                const horizontalRad = 40;
                const verticalPos = -15 + (Math.random() * 60);
                const x = Math.cos(t) * horizontalRad;
                const z = Math.sin(t) * -horizontalRad;
                return {
                    x: x,
                    y: verticalPos,
                    z: z + 25,
                    r: 0.3, g: 0, b: 0.3, s: 0.9,
                }; //wall/bg
            }

            // else if (i < total * 0.4) {
            //     const px = ((i % 4) < 2 ? 1 : -1) * 12; const pz = ((i % 4) % 2 == 0 ? 1 : -1) * 8;
            //     return { x: px + (Math.random() - 0.5) * 2, y: -15 + Math.random() * 30, z: pz + (Math.random() - 0.5) * 2, r: 0.2, g: 0.2, b: 0.2, s: 0.5 }; //pillar
            // }
            else if (i < total * 0.45) {
                const crossIndex = i % 6;
                const isHorizontal = (i % 12) >= 6;

                const baseX = Math.sin(crossIndex * 1.5) * 35;
                const baseZ = Math.cos(crossIndex * 2.2) * 20 - 10;

                if (!isHorizontal) {
                    //VERTICAL PILLAR
                    return {
                        x: baseX + (Math.random() - 0.5) * 1.5,
                        y: -15 + Math.random() * 35,
                        z: baseZ + (Math.random() - 0.5) * 1.5,
                        r: 0.2, g: 0.2, b: 0.2, s: 0.6,
                    };
                } else {
                    //HORIZONTAL BEAM (The Cross)
                    return {
                        x: baseX + (Math.random() - 0.5) * 10,
                        y: 10 + (Math.random() - 0.5),
                        z: baseZ + (Math.random() - 0.5) * 1.5,
                        r: 0.2, g: 0.2, b: 0.2, s: 0.6
                    };
                }
            }
            else if (i < total * 0.6) {
                const t = Math.random() * Math.PI;
                const horizontalRad = 40;
                const thickness = (Math.random() - 0.5);
                const x = Math.cos(t) * horizontalRad;
                const z = Math.sin(t) * -horizontalRad;

                const isWhite = (i % 2 === 1);
                const mixR = isWhite ? 0.3 : 0.8; // White (0.3) or Red (0.8)
                const mixG = isWhite ? 0.3 : 0.0; // White (0.3) or Red (0.0)
                const mixB = isWhite ? 0.3 : 0.0; // White (0.3) or Red (0.0)

                // --- KNOT LOGIC ---
                // This creates 10 equally spaced "zones" for the knots
                const knotCount = 10;
                const segment = (t / Math.PI) * knotCount;
                const localT = segment % 1; // 0.0 to 1.0 within a single knot area

                // Only use some particles to draw the knots (e.g., if they are near the center of a segment)
                const isKnotParticle = (i % 4 == 0);
                if (isKnotParticle) {
                    // 1. Two Circles at the top
                    if (localT > 0.4 && localT < 0.6) {
                        const side = (i % 2 === 0) ? -3 : 3;
                        return {
                            x: x + side,
                            y: 2 + (Math.random() + 0.5),
                            z: z + 20,
                            // r: 0.8, g: 0, b: 0, s: 0.6,
                            r: mixR, g: mixG, b: mixB, s: 2.0,
                        }
                    }
                    // 2. The "^" shape at the Bottom
                    else if (localT > 0.5 && localT < 0.9) {
                        const upwardSlant = (-0.7 + Math.abs(localT - 0.75)) * 10;
                        return {
                            x: x, // Horizontal spread of the ^
                            y: 13 + upwardSlant,         // Vertical peak
                            z: z + 20,
                            // r: 0.8, g: 0, b: 0, s: 0.6
                            r: mixR, g: mixG, b: mixB, s: 1.2,
                        };
                    }
                }
                return {
                    x: x,
                    y: 5 + thickness,
                    z: z + 20,
                    // r: 0.7, g: 0, b: 0, s: 0.1
                    r: mixR, g: mixG, b: mixB, s: 0.1,
                }; //ribbon
            }
            else return { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
        }

        // Hand Tracking
        let currentTech = 'neutral';
        let shakeIntensity = 0;
        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        let glowColor = '#00ffff';

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.9 });

        hands.onResults((results) => {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            let detected = 'neutral';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length == 1) {
                console.log(results.multiHandLandmarks);
                results.multiHandLandmarks.forEach((lm) => {
                    drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, { color: glowColor, lineWidth: 5 });
                    drawLandmarks(canvasCtx, lm, { color: '#fff', lineWidth: 1, radius: 2 });

                    const isUp = (t, p) => lm[t].y < lm[p].y;
                    const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    const pinch2 = Math.hypot(lm[12].x - lm[4].x, lm[12].y - lm[4].y);

                    const dx = lm[8].x - lm[4].x;
                    const dy = Math.abs(lm[8].y - lm[4].y);
                    const isUpright = dx > dy;

                    const dx2 = lm[12].x - lm[4].x;
                    const dy2 = Math.abs(lm[12].y - lm[4].y);
                    const isUpright2 = dx2 > dy2;

                    const dx3 = lm[8].y - lm[5].y;
                    const dy3 = Math.abs(lm[8].x - lm[5].x);
                    const isPointUp = dy3 > dx3;

                    if (results.multiHandLandmarks.length < 2) {
                        if ((pinch < 0.04 && isUpright) || (pinch2 < 0.04 && isUpright2)) detected = 'purple';
                        else if (isUp(8, 6) && isUp(12, 10) && !isUp(16, 14)) detected = 'void';
                        else if (isUp(8, 6) && !isUp(12, 10) && pinch > 0.16) detected = 'red';
                    }
                });
            }

            if (results.multiHandLandmarks.length >= 2) {
                results.multiHandLandmarks.forEach((lm) => {
                    drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, { color: glowColor, lineWidth: 5 });
                    drawLandmarks(canvasCtx, lm, { color: '#fff', lineWidth: 1, radius: 2 });
                });

                //=== SHRINE DE ===
                const checkCursedHandPose = (hand) => {
                    //side view check
                    const palmWidth = Math.abs(hand[5].x - hand[17].x);
                    const isSideView = palmWidth < 0.6;

                    //middle and ring open and upright check
                    const dxH1Middle = Math.abs(hand[12].x - hand[9].x);
                    const dyH1Middle = Math.abs(hand[12].y - hand[9].y);
                    const isMiddleUp = dyH1Middle > dxH1Middle && hand[12].y < hand[9].y;

                    const dxH1Ring = Math.abs(hand[16].x - hand[13].x);
                    const dyH1Ring = Math.abs(hand[16].y - hand[13].y);
                    const isRingUp = dyH1Ring > dxH1Ring && hand[16].y < hand[13].y;

                    //pinky curled check
                    const isCurlIndex = hand[8].y > hand[6].y;
                    const isCurlPinky = hand[20].y > hand[18].y;

                    return isSideView && isMiddleUp && isRingUp && isCurlPinky;
                };

                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];

                const interHandMiddleDist = Math.hypot(hand1[12].x - hand2[12].x, hand1[12].y - hand2[12].y);
                const interHandRingDist = Math.hypot(hand1[12].x - hand2[12].x, hand1[12].y - hand2[12].y);

                let isHandPoseShrineOK = false;
                let isHandPoseLoveOK = false;


                // if (checkCursedHandPose(hand1) && checkCursedHandPose(hand2)) {
                //     isHandPoseShrineOK = true;

                //     if (isHandPoseShrineOK && (interHandMiddleDist < 0.05 && interHandRingDist < 0.05)) detected = 'shrine';
                //     console.log(detected);
                // } else {
                //     isHandPoseShrineOK = false;
                // }
                //=== END OF SHRINE DE ===

                //=== LOVE DE ===
                const checkCursedHandPoseComeOn = (hand) => {
                    const thumbTip = hand[4];
                    const indexTip = hand[8];
                    const middleTip = hand[12];
                    const ringTip = hand[16];
                    const pinkyTip = hand[20];

                    const indexDCP = hand[7];
                    const middleDCP = hand[11];
                    const ringDCP = hand[15];
                    const pinkyDCP = hand[19];

                    const indexPIP = hand[6];
                    const middlePIP = hand[10];
                    const ringPIP = hand[14];
                    const pinkyPIP = hand[18];

                    const thumbIP = hand[3];

                    const indexMCP = hand[5];
                    const middleMCP = hand[9];
                    const ringMCP = hand[13];
                    const pinkyMCP = hand[17];

                    // Check if index, middle, ring, and pinky fingers are up
                    const isIndexUp = indexTip.y < indexPIP.y;
                    const isMiddleUp = middleTip.y < middlePIP.y;
                    const isRingUp = ringTip.y < ringPIP.y;
                    const isPinkyUp = pinkyTip.y < pinkyPIP.y;

                    return isIndexUp && isMiddleUp && isRingUp && isPinkyUp;
                };

                const checkCursedHandPoseClenched = (hand) => {
                    const thumbTip = hand[4];
                    const indexTip = hand[8];
                    const middleTip = hand[12];
                    const ringTip = hand[16];
                    const pinkyTip = hand[20];

                    const indexDCP = hand[7];
                    const middleDCP = hand[11];
                    const ringDCP = hand[15];
                    const pinkyDCP = hand[19];

                    const indexPIP = hand[6];
                    const middlePIP = hand[10];
                    const ringPIP = hand[14];
                    const pinkyPIP = hand[18];

                    const thumbIP = hand[3];

                    const indexMCP = hand[5];
                    const middleMCP = hand[9];
                    const ringMCP = hand[13];
                    const pinkyMCP = hand[17];

                    // Check if clenched fist
                    // const isThumbCurled = thumbTip.y > thumbIP.y;
                    const isIndexCurled = indexTip.y > indexMCP.y;
                    const isMiddleCurled = middleTip.y > middleMCP.y;
                    const isRingCurled = ringTip.y > ringMCP.y;
                    const isPinkyCurled = pinkyTip.y > pinkyPIP.y;

                    // Check if index, middle, and ring fingers are up
                    // const isIndexUp = indexTip.y < indexPIP.y;
                    // const isMiddleUp = middleTip.y < middlePIP.y;
                    // const isRingUp = ringTip.y < ringPIP.y;

                    return isIndexCurled && isMiddleCurled && isRingCurled && isPinkyCurled
                };

                if (checkCursedHandPose(hand1) && checkCursedHandPose(hand2)) {
                    isHandPoseShrineOK = true;

                    if (isHandPoseShrineOK && (interHandMiddleDist < 0.05 && interHandRingDist < 0.05)) detected = 'shrine';
                    console.log(detected);
                }
                else if (checkCursedHandPoseComeOn(hand1) && checkCursedHandPoseClenched(hand2)) {
                    isHandPoseLoveOK = true;

                    if (isHandPoseLoveOK) detected = 'love';
                    console.log(detected);
                }
                //=== END OF LOVE DE ===

            }
            updateState(detected);
        });

        function updateState(tech) {
            if (currentTech === tech) return;
            currentTech = tech;
            const nameEl = document.getElementById('technique-name');
            shakeIntensity = tech !== 'neutral' ? 0.4 : 0;

            if (tech === 'shrine') { glowColor = '#ff0000'; nameEl.innerText = "Domain Expansion: Malevolent Shrine"; bloomPass.strength = 2.5; }
            else if (tech === 'purple') { glowColor = '#bb00ff'; nameEl.innerText = "Secret Technique: Hollow Purple"; bloomPass.strength = 4.0; }
            else if (tech === 'void') { glowColor = '#00ffff'; nameEl.innerText = "Domain Expansion: Infinite Void"; bloomPass.strength = 2.0; }
            else if (tech === 'red') { glowColor = '#ff3333'; nameEl.innerText = "Reverse Cursed Technique: Red"; bloomPass.strength = 2.5; }
            else if (tech === 'love') { glowColor = '#e600cb'; nameEl.innerText = "Domain Expansion: All-Encompassing Unequivocal Love"; bloomPass.strength = 2.5; }
            else { glowColor = '#00ffff'; nameEl.innerText = "Neutral State"; bloomPass.strength = 1.0; }

            for (let i = 0; i < COUNT; i++) {
                let p;
                if (tech === 'neutral') {
                    if (i < COUNT * 0.05) {
                        const r = 15 + Math.random() * 20; const t = Math.random() * 6.28; const ph = Math.random() * 3.14;
                        p = { x: r * Math.sin(ph) * Math.cos(t), y: r * Math.sin(ph) * Math.sin(t), z: r * Math.cos(ph), r: 0.1, g: 0.1, b: 0.2, s: 0.4 };
                    } else p = { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
                }
                else if (tech === 'red') p = getRed(i);
                else if (tech === 'void') p = getVoid(i);
                else if (tech === 'purple') p = getPurple(i);
                else if (tech === 'shrine') p = getShrine(i);
                else if (tech === 'love') p = getLove(i);

                targetPositions[i * 3] = p.x; targetPositions[i * 3 + 1] = p.y; targetPositions[i * 3 + 2] = p.z;
                targetColors[i * 3] = p.r; targetColors[i * 3 + 1] = p.g; targetColors[i * 3 + 2] = p.b;
                targetSizes[i] = p.s;
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                await hands.send({ image: videoElement });
            }, width: 640, height: 480
        });
        cameraUtils.start();

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            const pulse = Math.sin(Date.now() * 0.002);

            if (shakeIntensity > 0) {
                renderer.domElement.style.transform = `translate(${(Math.random() - 0.5) * shakeIntensity * 40}px, ${(Math.random() - 0.5) * shakeIntensity * 40}px)`;
            } else {
                renderer.domElement.style.transform = 'translate(0,0)';
            }

            const pos = particles.geometry.attributes.position.array;
            const col = particles.geometry.attributes.color.array;
            const siz = particles.geometry.attributes.size.array;

            for (let i = 0; i < COUNT * 3; i++) {
                pos[i] += (targetPositions[i] - pos[i]) * 0.1;
                col[i] += (targetColors[i] - col[i]) * 0.1;
            }
            for (let i = 0; i < COUNT; i++) siz[i] += (targetSizes[i] - siz[i]) * 0.1;

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            // UPDATED ROTATION LOGIC: Locking rotation for Shrine
            if (currentTech === 'red') {
                particles.rotation.z -= 0.1;
            } else if (currentTech === 'purple') {
                particles.rotation.z += 0.2;
                particles.rotation.y += 0.05;
            } else if (currentTech === 'shrine') {
                // FORCE UPRIGHT: Reset and freeze all rotations
                particles.rotation.set(0, 0, 0);
            } else if (currentTech === 'love') {
                // FORCE UPRIGHT: Reset and freeze all rotations
                particles.rotation.set(0, 0, 0);

                particles.position.z = pulse;
                shakeIntensity = 0.05;
                if (shakeIntensity > 0) {
                    particles.position.z = pulse * (1 + shakeIntensity);
                }
            } else {
                // Default Neutral rotation
                particles.rotation.y += 0.005;
            }

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>